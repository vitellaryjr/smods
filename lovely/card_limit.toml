[manifest]
version = "1.0.0"
dump_lua = true
priority = -10

# Reset SMODS.cards_to_draw on game start
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'after'
pattern = '''
local saveTable = args.savetext or nil
'''
payload = '''
SMODS.cards_to_draw = nil
'''


# Set metatable
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'at'
pattern = '''
self.config = config or {}
'''
payload = '''
self.config = setmetatable({card_limits = {card_limit}}, {
    __index = function(t, key)
        if key == "card_limit" then
            return (t.card_limits.total_slots or 0) - (t.card_limits.extra_slots_used or 0)
        end
    end,
    __newindex = function(t, key, value)
        if key == 'card_limit' then
            if not t.card_limits.base then rawset(t.card_limits, 'base', value) end
            rawset(t.card_limits, 'mod', value - t.card_limits.base - (t.card_limits.extra_slots or 0))
        else
            rawset(t, key, value)
        end
    end
})

SMODS.merge_defaults(self.config, config)
'''

# Load metatable
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'at'
pattern = '''
self.config = cardAreaTable.config
'''
payload = '''
self.config = setmetatable(cardAreaTable.config, {
    __index = function(t, key)
        if key == "card_limit" then
            return (t.card_limits.total_slots or 0) - (t.card_limits.extra_slots_used or 0)
        end
    end,
    __newindex = function(t, key, value)
        if key == 'card_limit' then
            if not t.card_limits.base then rawset(t.card_limits, 'base', value) end
            rawset(t.card_limits, 'mod', value - t.card_limits.base - (t.card_limits.extra_slots or 0))
        else
            rawset(t, key, value)
        end
    end
})

'''

# Bypass CardArea:change_size()
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'after'
pattern = '''
function CardArea:change_size(delta)
'''
payload = '''
    if true then
        self.config.card_limits.mod = (self.config.card_limits.mod or 0) + delta
        return
    end
'''

# CardArea:update()
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'at'
pattern = '''
if self == G.deck and self.config.card_limit > #G.playing_cards then self.config.card_limit = #G.playing_cards end
'''
payload = '''
if self == G.deck and (self.config.card_limit ~= #G.playing_cards or self.config.total_slots ~= #G.playing_cards) then
    self.config.card_limit = #G.playing_cards
    self.config.card_limits.total_slots = #G.playing_cards
end
'''

# Card:add_to_deck()
# remove vanilla functionality
[[patches]]
[patches.pattern]
target = 'card.lua'
match_indent = true
position = 'at'
pattern = '''
if self.edition and self.edition.negative then 
            if from_debuff then 
                self.ability.queue_negative_removal = nil
            else
                if self.ability.consumeable then
                    G.consumeables.config.card_limit = G.consumeables.config.card_limit + 1
                else
                    G.jokers.config.card_limit = G.jokers.config.card_limit + 1
                end
            end
        end
'''
payload = '''
-- removed by SMODS
'''

# Card:remove_from_deck()
# remove vanilla functionality
[[patches]]
[patches.pattern]
target = 'card.lua'
match_indent = true
position = 'at'
pattern = '''
if self.edition and self.edition.negative and G.jokers then
            if from_debuff then
                self.ability.queue_negative_removal = true 
            else
                if self.ability.consumeable then
                    G.consumeables.config.card_limit = G.consumeables.config.card_limit - 1
                else
                    G.jokers.config.card_limit = G.jokers.config.card_limit - 1
                end 
            end
        end
'''
payload = '''
-- removed by SMODS
'''

# CardArea:update()
# Add support for extra_slots_used parameter
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'at'
pattern = '''
self.config.temp_limit = math.max(#self.cards, self.config.card_limit)
self.config.card_count = #self.cards
'''
payload = '''
self:handle_card_limit()
self.config.temp_limit = math.max(#self.cards, self.config.card_limit or 0)
'''

# CardArea:draw()
# Change count display to use true_card_limit
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
match_indent = true
position = 'at'
pattern = '''
{n=G.UIT.T, config={ref_table = self.config, ref_value = 'card_limit', scale = 0.3, colour = G.C.WHITE}},
'''
payload = '''
{n=G.UIT.T, config={ref_table = self.config.card_limits, ref_value = 'total_slots', scale = 0.3, colour = G.C.WHITE}},
'''

# Add negative info_queue support
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = self.GAME.starting_params.consumable_slots, type = 'joker', highlight_limit = 1})
'''
payload = '''
{card_limit = self.GAME.starting_params.consumable_slots, type = 'joker', highlight_limit = 1, negative_info = 'consumable'})
'''
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = self.GAME.starting_params.joker_slots, type = 'joker', highlight_limit = 1})
'''
payload = '''
{card_limit = self.GAME.starting_params.joker_slots, type = 'joker', highlight_limit = 1, negative_info = 'joker'})
'''
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = self.GAME.starting_params.hand_size, type = 'hand'})
'''
payload = '''
{card_limit = self.GAME.starting_params.hand_size, type = 'hand', negative_info = 'playing_card'})
'''
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = G.GAME.shop.joker_max, type = 'shop', highlight_limit = 1})
'''
payload = '''
{card_limit = G.GAME.shop.joker_max, type = 'shop', highlight_limit = 1, negative_info = true})
'''
[[patches]]
[patches.pattern]
target = 'game.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = 5, type = 'play'})
'''
payload = '''
{card_limit = 5, type = 'play', negative_info = 'playing_card'})
'''

# generate_card_ui()
# Adds info queue tooltips for generic card limit and slots used
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
match_indent = true
position = 'before'
pattern = '''
if first_pass and not (_c.set == 'Edition') and badges then
'''
payload = '''
if card and card.ability and (card.ability.extra_slots_used or 0) ~= 0 then
    local str = 'generic_extra_slots'
    if card.ability.set == 'Default' or card.ability.set == 'Enhanced' then str = str .. '_pc' end
    info_queue[#info_queue + 1] = {set = 'Other', key = str, vars = {card.ability.extra_slots_used + 1}}
end
if card and card.ability and (card.ability.card_limit or 0) ~= 0 then
    if not (card.edition and card.edition.card_limit == card.ability.card_limit) then
        local amount = card.ability.card_limit - (card.edition and card.edition.card_limit or 0)
        local str = 'generic_card_limit'
        if card.ability.set == 'Default' or card.ability.set == 'Enhanced' then str = str .. '_pc' end
        info_queue[#info_queue + 1] = {set = 'Other', key = amount == 1 and str or str..'_plural', vars = {localize({type='variable', key= amount > 0 and 'a_chips' or 'a_chips_minus', vars ={math.abs(amount)}})}}
    end
end
'''



# G.FUNCS.draw_from_deck_to_hand()
[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "local hand_space = e or*"
position = "at"
payload = """local hand_space = e
local cards_to_draw = {}
local space_taken = 0
local limit = G.hand.config.card_limit - #G.hand.cards - (SMODS.cards_to_draw or 0)
local flags = SMODS.calculate_context({drawing_cards = true, amount = limit})
limit = flags.cards_to_draw or flags.modify or limit
local unfixed = not G.hand.config.fixed_limit
local n = 0
while n < #G.deck.cards and limit > 0 do
    local card = G.deck.cards[#G.deck.cards-n]
    local mod = unfixed and (card.ability.card_limit - card.ability.extra_slots_used) or 0
    if limit - 1 + mod < 0 then
    else    
        limit = limit - 1 + mod
        table.insert(cards_to_draw, card)
        space_taken = space_taken + (1 - mod)
    end
    n = n + 1
end
hand_space = #cards_to_draw
"""
match_indent = true

# Handle The Serpent blind drawing
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'before'
pattern = '''
hand_space = math.min(#G.deck.cards, 3)
'''
payload = '''
G.hand.config.card_limits.blind_restriction = hand_space - math.min(#G.deck.cards, 3)
'''
# The Serpent only affects refilling the hand
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
match_indent = true
position = 'after'
pattern = '''
if G.GAME.blind.name == 'The Serpent' and
'''
payload = '''
    G.STATE == G.STATES.DRAW_TO_HAND and
'''


# check_for_unlock
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if args.type == 'min_hand_size' and G.hand and G.hand.config.card_limit <= card.unlock_condition.extra then"
position = "at"
payload = "if args.type == 'min_hand_size' and G.hand and G.hand.config.true_card_limit <= card.unlock_condition.extra then"
match_indent = true

# Challenge UI tooltip support
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'before'
pattern = '''
card_w = joker_size*G.CARD_W, type = 'title_2', highlight_limit = 0})
'''
payload = '''
negative_info = 'joker',
'''
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'before'
pattern = '''
card_w = joker_size*G.CARD_W, type = 'title_2', spread = true, highlight_limit = 0})
'''
payload = '''
negative_info = 'consumable',
'''
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
match_indent = true
position = 'at'
pattern = '''
{card_limit = #SUITS[suit_map[j]], type = 'title_2', view_deck = true, highlight_limit = 0, card_w = G.CARD_W*0.5, draw_layers = {'card'}})'''
payload = '''
{card_limit = #SUITS[suit_map[j]], type = 'title_2', view_deck = true, highlight_limit = 0, card_w = G.CARD_W*0.5, draw_layers = {'card'}, negative_info = 'playing_card'})'''